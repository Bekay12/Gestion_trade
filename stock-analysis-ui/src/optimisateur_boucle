import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import random
from qsi import backtest_signals,download_stock_data,modify_symbols_file,load_symbols_from_txt
from pathlib import Path
from tqdm import tqdm
import yfinance as yf
from collections import deque

def get_sector(symbol):
    """RÃ©cupÃ¨re le secteur d'une action avec logs pour diagnostic"""
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info
        sector = info.get('sector', 'â„¹ï¸Inconnu!!')
        print(f"ğŸ“‹ {symbol}: Secteur = {sector}")
        return sector
    except Exception as e:
        print(f"âš ï¸ Erreur pour {symbol}: {e}")
        return 'â„¹ï¸Inconnu!!'

# def optimize_sector_coefficients(sector_symbols, domain, period='1y', n_iterations=100, montant=50, transaction_cost=1.0):
#     """Optimise les coefficients pour un secteur donnÃ© via recherche alÃ©atoire en utilisant download_stock_data"""
#     if not sector_symbols:
#         print(f"ğŸš« Secteur {domain} vide, ignorÃ©")
#         return None, 0.0, (4.20, -0.5)
    
#     stock_data = download_stock_data(sector_symbols, period=period)
    
#     if not stock_data:
#         print(f"ğŸš¨ Aucune donnÃ©e tÃ©lÃ©chargÃ©e pour le secteur {domain}")
#         return None, 0.0, (4.20, -0.5)
    
#     for symbol, data in stock_data.items():
#         print(f"ğŸ“Š {symbol}: {len(data['Close'])} points de donnÃ©es")
    
#     best_gain_total = -float('inf')  # Optimiser sur le gain total
#     best_coeffs = None
#     best_thresholds = (4.20, -0.5)
#     tested_configs = deque(maxlen=80)  # Ensemble pour stocker les configurations testÃ©es
    
#     # Barre de progression principale avec tqdm
#     with tqdm(total=n_iterations, desc=f"ğŸ” Optimisation {domain}", unit="it") as pbar:   
#         for _ in range(n_iterations):
#             # GÃ©nÃ©rer des coefficients arrondis Ã  2 chiffres aprÃ¨s la virgule
#             coeffs = tuple(np.round(np.random.uniform(0.5, 3.0, 8), 2))
#             seuil_achat = np.round(np.random.uniform(2.0, 5.0), 2)
#             seuil_vente = np.round(np.random.uniform(-2.0, 0.0), 2)

#             # VÃ©rifier si la configuration a dÃ©jÃ  Ã©tÃ© testÃ©e
#             config_key = (coeffs, seuil_achat, seuil_vente)
#             if config_key in tested_configs:
#                 continue  # Passer Ã  la prochaine itÃ©ration si doublon
#             tested_configs.append(config_key)

#             total_gain = 0.0
#             total_trades = 0
#             total_success = 0
#             success_rate = 0.0
            
#             for symbol, data in stock_data.items():
#                 prices = data['Close']
#                 volumes = data['Volume']
                
#                 result = backtest_signals(
#                     prices, volumes, domain,
#                     domain_coeffs={domain: coeffs},
#                     montant=montant , transaction_cost=transaction_cost,
#                     seuil_achat=seuil_achat, seuil_vente=seuil_vente
#                 )

#                 total_gain += result['gain_total']
#                 total_trades += result['trades']
#                 total_success += result['gagnants']
#                 success_rate = (total_success / total_trades) * 100 if total_trades > 0 else 0.0
                    
#             avg_gain = total_gain / len(stock_data) if stock_data else 0.0
#             if _ == 0:
#                 print(f"ğŸ” Optimisation {domain} dÃ©marrÃ©e avec {len(stock_data)} symboles")
#                 print(f"ğŸ“ˆ ItÃ©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de rÃ©ussite = {success_rate:.2f}% ,")
            
#             if avg_gain > best_gain_total:
#                 best_gain_total = avg_gain
#                 best_coeffs = coeffs
#                 best_thresholds = (seuil_achat, seuil_vente)
#                 pbar.set_postfix({
#                     'Gain_moy': f"{best_gain_total:.2f}",
#                     'Success_Rate': f"{success_rate:.2f}%",
#                     'Seuil_Achat': f"{seuil_achat:.2f}",
#                     'Seuil_Vente': f"{seuil_vente:.2f}",
#                     'Trades': total_trades
#                 })

#                 save_optimization_results(domain, best_coeffs,best_gain_total, success_rate,total_trades, best_thresholds)
#             pbar.update(1)

#     if best_coeffs is None:
#         print(f"ğŸš¨ Aucun coefficient optimisÃ© pour {domain}: aucun signal ACHAT/VENTE gÃ©nÃ©rÃ©")

#     return best_coeffs, best_gain_total, success_rate, best_thresholds

def optimize_sector_coefficients(sector_symbols, domain, period='1y', n_iterations=30, montant=50, transaction_cost=1.0, 
                                initial_thresholds=(4.20, -0.5), max_cycles=2, convergence_threshold=0.1):
    """Optimise les coefficients et seuils en trois Ã©tapes itÃ©ratives jusqu'Ã  convergence via recherche alÃ©atoire"""
    if not sector_symbols:
        print(f"ğŸš« Secteur {domain} vide, ignorÃ©")
        return None, 0.0, 0.0, initial_thresholds
    
    stock_data = download_stock_data(sector_symbols, period=period)
    
    if not stock_data:
        print(f"ğŸš¨ Aucune donnÃ©e tÃ©lÃ©chargÃ©e pour le secteur {domain}")
        return None, 0.0, 0.0, initial_thresholds
    
    for symbol, data in stock_data.items():
        print(f"ğŸ“Š {symbol}: {len(data['Close'])} points de donnÃ©es")
    
    best_gain_total = -float('inf')
    best_coeffs = None
    best_thresholds = initial_thresholds
    best_success_rate = 0.0
    best_trades = 0
    cycle = 0
    
    while cycle < max_cycles:
        print(f"\nğŸ”„ Cycle {cycle + 1}/{max_cycles} pour {domain}")
        
        # Ã‰tape 1 : Optimiser les coefficients avec seuils fixes
        print(f"ğŸ” Ã‰tape 1 : Optimisation des coefficients avec seuils {best_thresholds}")
        current_gain_total = -float('inf')
        current_coeffs = None
        current_success_rate = 0.0
        current_trades = 0
        tested_configs = deque(maxlen=50)
        doublons = 0
        
        with tqdm(total=n_iterations, desc=f"ğŸ” Cycle {cycle + 1} - Ã‰tape 1 - Coeffs {domain}", unit="it") as pbar:
            for _ in range(n_iterations):
                coeffs = tuple(np.round(np.random.uniform(0.5, 3.0, 8), 1)) # # Coefficients arrondis Ã  1 chiffre aprÃ¨s la virgule
                config_key = coeffs
                
                if config_key in tested_configs:
                    doublons += 1
                    continue
                tested_configs.append(config_key)
                
                total_gain = 0.0
                total_trades = 0
                total_success = 0
                
                for symbol, data in stock_data.items():
                    prices = data['Close']
                    volumes = data['Volume']
                    
                    result = backtest_signals(
                        prices, volumes, domain,
                        domain_coeffs={domain: coeffs},
                        seuil_achat=best_thresholds[0], seuil_vente=best_thresholds[1],
                        montant=montant, transaction_cost=transaction_cost
                    )
                    
                    total_gain += result['gain_total']
                    total_trades += result['trades']
                    total_success += result['gagnants']
                
                avg_gain = total_gain / len(stock_data) if stock_data else 0.0
                success_rate = (total_success / total_trades * 100) if total_trades > 0 else 0.0
                if _ == 0:
                    print(f"ğŸ” Cycle {cycle + 1} - Ã‰tape 1 - Optimisation {domain} dÃ©marrÃ©e avec {len(stock_data)} symboles")
                    print(f"ğŸ“ˆ ItÃ©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de rÃ©ussite = {success_rate:.2f}%")
                
                if avg_gain > current_gain_total:
                    current_gain_total = avg_gain
                    current_coeffs = coeffs
                    current_success_rate = success_rate
                    current_trades = total_trades
                    pbar.set_postfix({
                        'Gain_moy': f"{current_gain_total:.2f}",
                        'Success_Rate': f"{success_rate:.2f}%",
                        'Trades': total_trades
                    })
                
                pbar.update(1)
            
            print(f"ğŸ“Š Cycle {cycle + 1} - Ã‰tape 1 - Nombre de doublons Ã©vitÃ©s : {doublons}")
        
        if current_coeffs is None:
            print(f"ğŸš¨ Cycle {cycle + 1} - Ã‰tape 1 - Aucun coefficient optimisÃ© pour {domain}: aucun signal ACHAT/VENTE gÃ©nÃ©rÃ©")
            return None, 0.0, 0.0, best_thresholds
        
        print(f"âœ… Cycle {cycle + 1} - Ã‰tape 1 - Meilleurs coefficients : {current_coeffs}, Gain moyen = {current_gain_total:.2f}")
        
        # Ã‰tape 2 : Optimiser le seuil d'achat avec coefficients et seuil de vente fixes
        print(f"ğŸ” Ã‰tape 2 : Optimisation du seuil d'achat avec coefficients {current_coeffs} et seuil de vente {best_thresholds[1]}")
        tested_configs = deque(maxlen=50)
        doublons = 0
        current_seuil_achat = best_thresholds[0]
        
        with tqdm(total=n_iterations, desc=f"ğŸ” Cycle {cycle + 1} - Ã‰tape 2 - Seuil Achat {domain}", unit="it") as pbar:
            for _ in range(n_iterations):
                seuil_achat = np.round(np.random.uniform(2.5, 6.0), 2)
                config_key = seuil_achat
                
                if config_key in tested_configs:
                    doublons += 1
                    continue
                tested_configs.append(config_key)
                
                total_gain = 0.0
                total_trades = 0
                total_success = 0
                
                for symbol, data in stock_data.items():
                    prices = data['Close']
                    volumes = data['Volume']
                    
                    result = backtest_signals(
                        prices, volumes, domain,
                        domain_coeffs={domain: current_coeffs},
                        seuil_achat=seuil_achat, seuil_vente=best_thresholds[1],
                        montant=montant, transaction_cost=transaction_cost
                    )
                    
                    total_gain += result['gain_total']
                    total_trades += result['trades']
                    total_success += result['gagnants']
                
                avg_gain = total_gain / len(stock_data) if stock_data else 0.0
                success_rate = (total_success / total_trades * 100) if total_trades > 0 else 0.0
                if _ == 0:
                    print(f"ğŸ” Cycle {cycle + 1} - Ã‰tape 2 - Optimisation {domain} dÃ©marrÃ©e avec {len(stock_data)} symboles")
                    print(f"ğŸ“ˆ ItÃ©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de rÃ©ussite = {success_rate:.2f}%")
                
                if avg_gain > current_gain_total:
                    current_gain_total = avg_gain
                    current_seuil_achat = seuil_achat
                    current_success_rate = success_rate
                    current_trades = total_trades
                    pbar.set_postfix({
                        'Gain_moy': f"{current_gain_total:.2f}",
                        'Success_Rate': f"{success_rate:.2f}%",
                        'Seuil_Achat': f"{seuil_achat:.2f}",
                        'Trades': total_trades
                    })
                
                pbar.update(1)
            
            print(f"ğŸ“Š Cycle {cycle + 1} - Ã‰tape 2 - Nombre de doublons Ã©vitÃ©s : {doublons}")
        
        print(f"âœ… Cycle {cycle + 1} - Ã‰tape 2 - Meilleur seuil d'achat : {current_seuil_achat}, Gain moyen = {current_gain_total:.2f}")
        
        # Ã‰tape 3 : Optimiser le seuil de vente avec coefficients et seuil d'achat fixes
        print(f"ğŸ” Ã‰tape 3 : Optimisation du seuil de vente avec coefficients {current_coeffs} et seuil d'achat {current_seuil_achat}")
        tested_configs = deque(maxlen=50)
        doublons = 0
        current_seuil_vente = best_thresholds[1]
        
        with tqdm(total=n_iterations, desc=f"ğŸ” Cycle {cycle + 1} - Ã‰tape 3 - Seuil Vente {domain}", unit="it") as pbar:
            for _ in range(n_iterations):
                seuil_vente = np.round(np.random.uniform(-3.0, 0.0), 2)
                config_key = seuil_vente
                
                if config_key in tested_configs:
                    doublons += 1
                    continue
                tested_configs.append(config_key)
                
                total_gain = 0.0
                total_trades = 0
                total_success = 0
                
                for symbol, data in stock_data.items():
                    prices = data['Close']
                    volumes = data['Volume']
                    
                    result = backtest_signals(
                        prices, volumes, domain,
                        domain_coeffs={domain: current_coeffs},
                        seuil_achat=current_seuil_achat, seuil_vente=seuil_vente,
                        montant=montant, transaction_cost=transaction_cost
                    )
                    
                    total_gain += result['gain_total']
                    total_trades += result['trades']
                    total_success += result['gagnants']
                
                avg_gain = total_gain / len(stock_data) if stock_data else 0.0
                success_rate = (total_success / total_trades * 100) if total_trades > 0 else 0.0
                if _ == 0:
                    print(f"ğŸ” Cycle {cycle + 1} - Ã‰tape 3 - Optimisation {domain} dÃ©marrÃ©e avec {len(stock_data)} symboles")
                    print(f"ğŸ“ˆ ItÃ©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de rÃ©ussite = {success_rate:.2f}%")
                
                if avg_gain > current_gain_total:
                    current_gain_total = avg_gain
                    current_seuil_vente = seuil_vente
                    current_success_rate = success_rate
                    current_trades = total_trades
                    pbar.set_postfix({
                        'Gain_moy': f"{current_gain_total:.2f}",
                        'Success_Rate': f"{success_rate:.2f}%",
                        'Seuil_Vente': f"{seuil_vente:.2f}",
                        'Trades': total_trades
                    })
                
                pbar.update(1)
            
            print(f"ğŸ“Š Cycle {cycle + 1} - Ã‰tape 3 - Nombre de doublons Ã©vitÃ©s : {doublons}")
        
        current_thresholds = (current_seuil_achat, current_seuil_vente)
        print(f"âœ… Cycle {cycle + 1} - Ã‰tape 3 - Meilleur seuil de vente : {current_seuil_vente}, Gain moyen = {current_gain_total:.2f}")
        
        # Mise Ã  jour des meilleurs paramÃ¨tres
        if current_gain_total > best_gain_total:
            improvement = current_gain_total - best_gain_total
            best_gain_total = current_gain_total
            best_coeffs = current_coeffs
            best_thresholds = current_thresholds
            best_success_rate = current_success_rate
            best_trades = current_trades
            print(f"âœ… Cycle {cycle + 1} - AmÃ©lioration du gain : {improvement:.2f}")
            save_optimization_results(domain, best_coeffs, best_gain_total, best_success_rate, best_trades, best_thresholds)
        else:
            print(f"âœ… Cycle {cycle + 1} - Aucune amÃ©lioration significative, arrÃªt anticipÃ©")
            break
        
        # CritÃ¨re de convergence
        if improvement < convergence_threshold:
            print(f"âœ… Cycle {cycle + 1} - Convergence atteinte (amÃ©lioration < {convergence_threshold})")
            break
        
        cycle += 1
    
    if best_coeffs is None:
        print(f"ğŸš¨ Aucun coefficient optimisÃ© pour {domain}: aucun signal ACHAT/VENTE gÃ©nÃ©rÃ©")
    else:
        save_optimization_results(domain, best_coeffs, best_gain_total, best_success_rate, best_trades, best_thresholds)
    
    return best_coeffs, best_gain_total, best_success_rate, best_thresholds

def save_optimization_results(sector, coeffs,gain_total, success_rate, trade, thresholds, filename="signaux/optimization_hist_3stp.csv"):
    """Enregistre les rÃ©sultats de l'optimisation dans un CSV Ã©volutif"""
    file_path = Path(filename)
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # CrÃ©er une ligne pour le CSV
    row = {
        'Timestamp': timestamp,
        'Sector': sector,
        'Gain_moy': round(gain_total, 2),
        'Success_Rate': round(success_rate, 4),
        'Trades': trade,
        'Seuil_Achat': round(thresholds[0], 2),
        'Seuil_Vente': round(thresholds[1], 2),
        'a1': round(coeffs[0], 3),
        'a2': round(coeffs[1], 3),
        'a3': round(coeffs[2], 3),
        'a4': round(coeffs[3], 3),
        'a5': round(coeffs[4], 3),
        'a6': round(coeffs[5], 3),
        'a7': round(coeffs[6], 3),
        'a8': round(coeffs[7], 3)
    }
    
    # Convertir en DataFrame
    df_new = pd.DataFrame([row])
    
    # Si le fichier existe, ajouter les donnÃ©es
    if file_path.exists():
        try:
            df_old = pd.read_csv(file_path)
            df_combined = pd.concat([df_old, df_new], ignore_index=True)
        except Exception as e:
            print(f"âš ï¸ Erreur lecture CSV: {e}")
            df_combined = df_new
    else:
        df_combined = df_new
    
    # CrÃ©er le dossier 'signaux' si nÃ©cessaire
    file_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Sauvegarder
    try:
        df_combined.to_csv(file_path, index=False)
        print(f"ğŸ’¾ RÃ©sultats enregistrÃ©s dans {file_path}")
    except Exception as e:
        print(f"ğŸš¨ Erreur sauvegarde CSV: {e}")

# Exemple d'utilisation
if __name__ == "__main__":
    # Exemple de symboles par secteur, incluant cryptomonnaies et inconnus
    symbols = list(dict.fromkeys(load_symbols_from_txt("optimisation_symbols.txt")))
    # CrÃ©er le dictionnaire des secteurs dynamiquement
    sectors = {
        "Technology": [],
        "Healthcare": [],  
        "Financial Services":[],
        "Consumer Cyclical":  [],
        "Industrials":     [],
        "Energy":          [],
        "Basic Materials": [],
        "Communication Services": [],
        "Utilities":      [],
        "Real Estate":  [],
        "â„¹ï¸Inconnu!!": []
    }
    
    # Assigner les symboles aux secteurs
    for symbol in symbols:
        sector = get_sector(symbol)
        if sector in sectors:
            sectors[sector].append(symbol)
        else:
            sectors["â„¹ï¸Inconnu!!"].append(symbol)
    
    print("\nğŸ“‹ Assignation des secteurs:")
    for sector, syms in sectors.items():
        print(f"{sector}: {syms}")
    
    optimized_coeffs = {}
    for sector, sector_symbols in sectors.items():
        if not sector_symbols:
            print(f"ğŸš« Secteur {sector} vide, ignorÃ©")
            continue
        coeffs, gain_total, success_rate, thresholds = optimize_sector_coefficients(
            sector_symbols, sector, period='1y', n_iterations=100, montant=50, 
            transaction_cost=0.02, max_cycles=5, convergence_threshold=0.1
        )
        if coeffs:
            optimized_coeffs[sector] = coeffs
            print(f"\nSecteur: {sector}")
            print(f"Meilleurs coefficients: {coeffs}")
            print(f"Meilleurs seuils (achat, vente): {thresholds}")
            print(f"Gain total moyen: {gain_total:.2f}")
            print(f"Taux de rÃ©ussite: {success_rate:.2f}%")
    
    print("Dictionnaire optimisÃ© pour domain_coeffs:")
    print("{")
    for sector, coeffs in optimized_coeffs.items():
        print(f"    '{sector}': {coeffs},")
    print("}")