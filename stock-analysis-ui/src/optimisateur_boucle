import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import random
from qsi import backtest_signals,download_stock_data,get_trading_signal, popular_symbols, mes_symbols, period
from pathlib import Path
from tqdm import tqdm
import yfinance as yf

# Assurez-vous que votre fonction get_trading_signal est d√©finie ici ou import√©e
# from your_module import get_trading_signal, download_stock_data

def evaluate_signal(prices, signal, horizon=5, threshold=0.02):
    """√âvalue la pr√©cision d'un signal sur un horizon donn√©"""
    if len(prices) < horizon:
        return 0
    future_price = prices.shift(-horizon).iloc[-1]
    current_price = prices.iloc[-1]
    if signal == "ACHAT":
        return 1 if (future_price / current_price - 1) > threshold else 0
    elif signal == "VENTE":
        return 1 if (future_price / current_price - 1) < -threshold else 0
    return 0

def get_sector(symbol):
    """R√©cup√®re le secteur d'une action avec logs pour diagnostic"""
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info
        sector = info.get('sector', '‚ÑπÔ∏èInconnu!!')
        print(f"üìã {symbol}: Secteur = {sector}")
        return sector
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur pour {symbol}: {e}")
        return '‚ÑπÔ∏èInconnu!!'

def optimize_sector_coefficients(sector_symbols, domain, period='1y', n_iterations=100, montant=50, transaction_cost=1.0):
    """Optimise les coefficients pour un secteur donn√© via recherche al√©atoire en utilisant download_stock_data"""
    if not sector_symbols:
        print(f"üö´ Secteur {domain} vide, ignor√©")
        return None, 0.0, (4.20, -0.5)
    
    stock_data = download_stock_data(sector_symbols, period=period)
    
    if not stock_data:
        print(f"üö® Aucune donn√©e t√©l√©charg√©e pour le secteur {domain}")
        return None, 0.0, (4.20, -0.5)
    
    for symbol, data in stock_data.items():
        print(f"üìä {symbol}: {len(data['Close'])} points de donn√©es")
    
    best_gain_total = -float('inf')  # Optimiser sur le gain total
    best_coeffs = None
    best_thresholds = (4.20, -0.5)
    
    # Barre de progression principale avec tqdm
    with tqdm(total=n_iterations, desc=f"üîç Optimisation {domain}", unit="it") as pbar:   
        for _ in range(n_iterations):
            # G√©n√©rer des coefficients al√©atoires dans une plage raisonnable
            coeffs = tuple(np.random.uniform(0.5, 3.0, 8))
            seuil_achat = np.random.uniform(3.0, 6.0)
            seuil_vente = np.random.uniform(-2, 0.0)

            total_gain = 0.0
            total_trades = 0
            total_success_rate = 0.0
            
            for symbol, data in stock_data.items():
                prices = data['Close']
                volumes = data['Volume']
                
                result = backtest_signals(
                    prices, volumes, domain,
                    domain_coeffs={domain: coeffs},
                    montant=montant , transaction_cost=transaction_cost,
                    seuil_achat=seuil_achat, seuil_vente=seuil_vente
                )

                total_gain += result['gain_total']
                total_trades += result['trades']
                total_success_rate += result['taux_reussite']
                    
            avg_gain = total_gain / len(stock_data) if stock_data else 0.0
            avg_success_rate = total_success_rate / len(stock_data) if stock_data else 0.0
            if _ == 0:
                print(f"üìà It√©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de r√©ussite = {avg_success_rate:.2f}%")
            
            if avg_gain > best_gain_total:
                best_gain_total = avg_gain
                best_coeffs = coeffs
                best_thresholds = (seuil_achat, seuil_vente)
                pbar.set_postfix({
                    'Best_Gain': f"{best_gain_total:.2f}",
                    'Success_Rate': f"{avg_success_rate:.2f}%",
                    'Seuil_Achat': f"{seuil_achat:.2f}",
                    'Seuil_Vente': f"{seuil_vente:.2f}",
                    'Trades': total_trades
                })

                save_optimization_results(domain, best_coeffs,best_gain_total, avg_success_rate,total_trades, best_thresholds)
            pbar.update(1)

    if best_coeffs is None:
        print(f"üö® Aucun coefficient optimis√© pour {domain}: aucun signal ACHAT/VENTE g√©n√©r√©")

    return best_coeffs, best_gain_total, avg_success_rate, best_thresholds

def save_optimization_results(sector, coeffs,gain_total, success_rate, trade, thresholds, filename="signaux/optimization_history.csv"):
    """Enregistre les r√©sultats de l'optimisation dans un CSV √©volutif"""
    file_path = Path(filename)
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Cr√©er une ligne pour le CSV
    row = {
        'Timestamp': timestamp,
        'Sector': sector,
        'Best_Gain': round(gain_total, 2),
        'Success_Rate': round(success_rate, 4),
        'Trades': trade,
        'Seuil_Achat': round(thresholds[0], 2),
        'Seuil_Vente': round(thresholds[1], 2),
        'a1': round(coeffs[0], 3),
        'a2': round(coeffs[1], 3),
        'a3': round(coeffs[2], 3),
        'a4': round(coeffs[3], 3),
        'a5': round(coeffs[4], 3),
        'a6': round(coeffs[5], 3),
        'a7': round(coeffs[6], 3),
        'a8': round(coeffs[7], 3)
    }
    
    # Convertir en DataFrame
    df_new = pd.DataFrame([row])
    
    # Si le fichier existe, ajouter les donn√©es
    if file_path.exists():
        try:
            df_old = pd.read_csv(file_path)
            df_combined = pd.concat([df_old, df_new], ignore_index=True)
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur lecture CSV: {e}")
            df_combined = df_new
    else:
        df_combined = df_new
    
    # Cr√©er le dossier 'signaux' si n√©cessaire
    file_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Sauvegarder
    try:
        df_combined.to_csv(file_path, index=False)
        print(f"üíæ R√©sultats enregistr√©s dans {file_path}")
    except Exception as e:
        print(f"üö® Erreur sauvegarde CSV: {e}")

# Exemple d'utilisation
if __name__ == "__main__":
    # Exemple de symboles par secteur, incluant cryptomonnaies et inconnus
    symbols = list(dict.fromkeys([
        "AAPL", "MSFT","PLTR", "QBTS", "TSM", "NVDA",
        "PFE", "JNJ", "MRK","SGMT", "JPM", "BAC", "WFC",
        "AMZN", "TSLA", "NKE","BA", "CAT", "GE","ENR.DE",
        "XOM", "CVX", "BP","FCX", "NEM", "BHP","FNV.TO",
        "VZ", "T", "GOOGL", "META","NEE", "DUK", "SO",
        "AMT", "PLD", "SPG","GLD", "SPY",
    ]))
    # Cr√©er le dictionnaire des secteurs dynamiquement
    sectors = {
        # "Technology": [],
        "Healthcare": [],  
        # "Financial Services":[],
        # "Consumer Cyclical":  [],
        # "Industrials":     [],
        # "Energy":          [],
        # "Basic Materials": [],
        # "Communication Services": [],
        # "Utilities":      [],
        # "Real Estate":  [],
        "‚ÑπÔ∏èInconnu!!": []
    }
    
    # Assigner les symboles aux secteurs
    for symbol in symbols:
        sector = get_sector(symbol)
        if sector in sectors:
            sectors[sector].append(symbol)
        else:
            sectors["‚ÑπÔ∏èInconnu!!"].append(symbol)

    optimized_coeffs = {}
    for sector, sector_symbols in sectors.items():
        if not sector_symbols:
            print(f"üö´ Secteur {sector} vide, ignor√©")
            continue
        coeffs, gain_total, thresholds,*_ = optimize_sector_coefficients(
            sector_symbols, sector, period='1y', montant=50, transaction_cost=0.00
        )
        if coeffs:
            optimized_coeffs[sector] = coeffs
            print(f"\nSecteur: {sector}")
            print(f"Meilleurs coefficients: {coeffs}")
            print(f"Meilleurs seuils (achat, vente): {thresholds}")
            print(f"Gain total moyen: {gain_total:.2f}\n")
    
    # G√©n√©rer le dictionnaire Python
    print("Dictionnaire optimis√© pour domain_coeffs:")
    print("{")
    for sector, coeffs in optimized_coeffs.items():
        print(f"    '{sector}': {coeffs},")
    print("}")