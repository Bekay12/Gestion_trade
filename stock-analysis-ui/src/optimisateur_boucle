from qsi import download_stock_data, analyse_signaux_populaires, get_trading_signal, popular_symbols, mes_symbols, period
import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import ta
import time
import csv
import itertools
from tqdm import tqdm


def get_sector(symbol):
    """RÃ©cupÃ¨re le secteur d'une action"""
    try:
        ticker = yf.Ticker(symbol)
        return ticker.info.get('sector', 'Unknown')
    except:
        return 'Unknown'

def grid_search_sector_coefficients(symbols_sample):
    """Recherche en grille dans l'espace de coefficients dÃ©fini"""
    # Votre configuration initiale
    base_coeffs = {
        "Technology": (2.0, 1.5, 1.3, 1.5, 1.8, 1.5, 1.4, 1.2),
        "Healthcare": (1.8, 1.1, 1.6, 1.3, 1.8, 1.3, 1.3, 1.8),
        "Financial Services": (1.6, 1.9, 2.3, 1.2, 1.6, 1.1, 1.2, 1.6),
        "Consumer Cyclical": (1.7, 1.0, 1.4, 1.2, 1.7, 1.2, 1.7, 1.7),
        "Industrials": (1.7, 1.2, 1.2, 1.0, 1.5, 1.0, 1.2, 1.5),
        "Energy": (1.4, 1.7, 1.1, 1.1, 1.4, 0.9, 0.7, 1.4),
        "Basic Materials": (1.3, 1.6, 1.0, 1.8, 1.3, 0.8, 0.6, 1.3),
        "Communication Services": (1.6, 1.0, 1.3, 1.1, 1.6, 1.1, 1.0, 1.6),
        "Utilities": (1.8, 1.5, 1.2, 1.3, 1.2, 1.3, 0.5, 1.2),
        "Real Estate": (1.1, 1.6, 1.2, 1.4, 1.1, 1.4, 0.4, 1.1)
    }
    
    # Espace de recherche pour les variations
    variations = [0.8, 1.0, 1.2]  # -20%, mÃªme, +20%
    seuils_achat = [4.5, 5.0, 5.5]
    seuils_vente = [-1.0, -2.0, -3.0]
    
    best_accuracy = 0
    best_config = None
    
    # CrÃ©er toutes les combinaisons possibles
    all_combinations = list(itertools.product(variations, variations, variations))
    total_combinations = len(all_combinations) * len(seuils_achat) * len(seuils_vente)
    
    with tqdm(total=total_combinations, desc="ğŸ” Recherche sectorielle", unit="comb") as pbar:
        for variation_combo in all_combinations:
            # CrÃ©er une nouvelle configuration basÃ©e sur les variations
            new_coeffs = {}
            for sector, coeffs in base_coeffs.items():
                new_coeffs[sector] = tuple(c * v for c, v in zip(coeffs, variation_combo))
            
            for seuil_achat in seuils_achat:
                for seuil_vente in seuils_vente:
                    try:
                        accuracy = evaluate_sector_coefficients(
                            symbols_sample,
                            new_coeffs,
                            seuil_achat,
                            seuil_vente
                        )
                        
                        if accuracy > best_accuracy:
                            best_accuracy = accuracy
                            best_config = {
                                'coeffs': new_coeffs,
                                'seuil_achat': seuil_achat,
                                'seuil_vente': seuil_vente
                            }
                            pbar.set_postfix({'best_acc': f"{best_accuracy:.2%}"})
                            
                    except Exception as e:
                        pbar.set_postfix({'error': str(e)[:20] + '...'})
                    
                    pbar.update(1)
    
    return best_config['coeffs'], (best_config['seuil_achat'], best_config['seuil_vente']), best_accuracy

def evaluate_simple(symbols, seuil_achat, seuil_vente, rsi_window, macd_fast):
    """Ã‰valuation rapide sur un sous-ensemble"""
    correct = 0
    total = 0
    
    for symbol in symbols:
        data = download_stock_data([symbol], "12mo")[symbol]
        prices = data['Close']
        volumes = data['Volume']
        domaine = get_sector(symbol)
        
        # GÃ©nÃ©rer signal avec paramÃ¨tres actuels
        signal = get_trading_signal(
            prices, volumes, domaine,
            seuil_achat=seuil_achat,
            seuil_vente=seuil_vente,
        )[0]
        
        # Ã‰valuer la performance Ã  5 jours
        future_5d = (prices.iloc[-1] - prices.iloc[-6]) / prices.iloc[-6]
        
        if signal == "ACHAT" and future_5d > 0.02:
            correct += 1
        elif signal == "VENTE" and future_5d < -0.02:
            correct += 1
            
        total += 1
    
    return correct / total if total > 0 else 0



def optimize_sector_coefficients(symbols_sample, n_iter=50):
    """Optimisation des coefficients par secteur avec recherche alÃ©atoire"""
    # Liste de tous les secteurs
    all_sectors = [
        "Technology", "Healthcare", "Financial Services", 
        "Consumer Cyclical", "Industrials", "Energy",
        "Basic Materials", "Communication Services", 
        "Utilities", "Real Estate"
    ]
    
    # Plages de valeurs pour les coefficients
    coeff_range = np.linspace(0.5, 3.0, 10)  # 10 valeurs entre 0.5 et 3.0
    
    best_accuracy = 0
    best_coeffs = None
    best_seuils = None
    
    # Barre de progression principale
    with tqdm(total=n_iter, desc="ğŸ” Optimisation sectorielle", unit="it") as pbar:
        for i in range(n_iter):
            # GÃ©nÃ©rer une configuration alÃ©atoire pour tous les secteurs
            random_coeffs = {}
            for sector in all_sectors:
                # GÃ©nÃ©rer 8 coefficients alÃ©atoires pour ce secteur
                random_coeffs[sector] = tuple(np.random.choice(coeff_range, size=8))
            
            # GÃ©nÃ©rer des seuils alÃ©atoires
            random_seuil_achat = np.random.uniform(4.0, 6.0)
            random_seuil_vente = np.random.uniform(-3.0, -0.5)
            
            try:
                accuracy = evaluate_sector_coefficients(
                    symbols_sample,
                    random_coeffs,
                    random_seuil_achat,
                    random_seuil_vente
                )
                
                if accuracy > best_accuracy:
                    best_accuracy = accuracy
                    best_coeffs = random_coeffs
                    best_seuils = (random_seuil_achat, random_seuil_vente)
                    pbar.set_postfix({'best_acc': f"{best_accuracy:.2%}"})
                    
            except Exception as e:
                pbar.set_postfix({'error': str(e)[:20] + '...'})
            
            pbar.update(1)
    
    return best_coeffs, best_seuils, best_accuracy

def evaluate_sector_coefficients(symbols, sector_coeffs, seuil_achat, seuil_vente):
    """Ã‰value une configuration de coefficients sectoriels"""
    correct = 0
    total = 0
    
    for symbol in symbols:
        data = download_stock_data([symbol], "6mo").get(symbol)
        if not data:
            continue
            
        prices = data['Close']
        volumes = data['Volume']
        secteur = get_sector(symbol)
        
        # GÃ©nÃ©rer le signal avec les coefficients du secteur
        signal = get_trading_signal(
            prices, volumes, secteur,
            domain_coeffs=sector_coeffs,
            seuil_achat=seuil_achat,
            seuil_vente=seuil_vente
        )[0]
        
        # Ã‰valuer la performance Ã  5 jours
        if len(prices) > 5:
            future_5d = (prices.iloc[-1] - prices.iloc[-6]) / prices.iloc[-6]
            
            if signal == "ACHAT" and future_5d > 0.02:
                correct += 1
            elif signal == "VENTE" and future_5d < -0.02:
                correct += 1
                
            total += 1
    
    return correct / total if total > 0 else 0

# Fonction pour appliquer les coefficients optimisÃ©s
def apply_optimized_coeffs(optimized_coeffs):
    """Applique les coefficients optimisÃ©s dans le code principal"""
    print("\nâœ… Coefficients optimisÃ©s par secteur:")
    for sector, coeffs in optimized_coeffs.items():
        print(f"{sector}: {coeffs}")
    
    # Dans votre fonction get_trading_signal, remplacez:
    domain_coeffs = optimized_coeffs
    
    return domain_coeffs

# Exemple d'utilisation
if __name__ == "__main__":
    symboles_test = mes_symbols[:30]  # 30 symboles pour l'optimisation
    
    best_coeffs, best_seuils, best_accuracy = optimize_sector_coefficients(symboles_test, n_iter=100)
    
    print("\nğŸ” Optimisation terminÃ©e!")
    print(f"- Meilleure prÃ©cision: {best_accuracy:.2%}")
    print(f"- Meilleur seuil achat: {best_seuils[0]:.2f}")
    print(f"- Meilleur seuil vente: {best_seuils[1]:.2f}")
    
    # Appliquer les coefficients optimisÃ©s
    domain_coeffs = apply_optimized_coeffs(best_coeffs)
    print("\nğŸ”§ Coefficients appliquÃ©s dans le systÃ¨me.")

def display_optimization_results(best_coeffs, best_seuils, best_accuracy):
    """Affiche les rÃ©sultats de l'optimisation de maniÃ¨re lisible"""
    # En-tÃªte
    print("\n" + "="*70)
    print("ğŸ”¥ RÃ‰SULTATS DE L'OPTIMISATION SECTORIELLE")
    print("="*70)
    
    # Affichage de la prÃ©cision
    print(f"\nğŸ¯ PRÃ‰CISION OPTIMISÃ‰E: {best_accuracy:.2%}\n")
    
    # Affichage des seuils
    seuil_achat, seuil_vente = best_seuils
    print("âš–ï¸ SEUILS OPTIMAUX:")
    print(f"- Seuil ACHAT: {seuil_achat:.2f}")
    print(f"- Seuil VENTE: {seuil_vente:.2f}")
    print("-"*50)
    
    # Affichage des coefficients par secteur
    print("\nğŸ“Š COEFFICIENTS OPTIMISÃ‰S PAR SECTEUR:")
    print("Secteur               a1     a2     a3     a4     a5     a6     a7     a8")
    print("-"*70)
    
    for sector, coeffs in best_coeffs.items():
        # Formatage des coefficients
        formatted_coeffs = [f"{c:.3f}" for c in coeffs]
        # Affichage alignÃ©
        print(f"{sector[:20]:<20} {formatted_coeffs[0]:>6} {formatted_coeffs[1]:>6} {formatted_coeffs[2]:>6} "
              f"{formatted_coeffs[3]:>6} {formatted_coeffs[4]:>6} {formatted_coeffs[5]:>6} "
              f"{formatted_coeffs[6]:>6} {formatted_coeffs[7]:>6}")
    
    # Pied de page
    print("\n" + "="*70)
    print("="*70)

# Exemple d'utilisation aprÃ¨s l'optimisation
if __name__ == "__main__":
    # ExÃ©cution de l'optimisation
    best_coeffs, best_seuils, best_accuracy = grid_search_sector_coefficients(mes_symbols[:15])
    
    # Affichage des rÃ©sultats
    display_optimization_results(best_coeffs, best_seuils, best_accuracy)
    
    # GÃ©nÃ©ration d'un dictionnaire Python prÃªt Ã  l'emploi
    print("\nğŸ“ DICTIONNAIRE PYTHON PRÃŠT Ã€ COPIER-COLLER:")
    print("domain_coeffs = {")
    for sector, coeffs in best_coeffs.items():
        coeffs_str = ", ".join([f"{c:.3f}" for c in coeffs])
        print(f'    "{sector}": ({coeffs_str}),')
    print("}")

# grid_search_sector_coefficients(mes_symbols[:10])  # Utiliser un Ã©chantillon rÃ©duit pour la recherche en grille

# MÃ©thode de grille (plus systÃ©matique mais plus lente)
# best_coeffs, best_seuils, best_accuracy = grid_search_sector_coefficients(mes_symbols[:10])