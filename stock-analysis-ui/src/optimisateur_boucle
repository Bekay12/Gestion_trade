import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import random
from qsi import backtest_signals,download_stock_data,modify_symbols_file,load_symbols_from_txt
from pathlib import Path
from tqdm import tqdm
import yfinance as yf
from collections import deque

def get_sector(symbol):
    """RÃ©cupÃ¨re le secteur d'une action avec logs pour diagnostic"""
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info
        sector = info.get('sector', 'â„¹ï¸Inconnu!!')
        print(f"ğŸ“‹ {symbol}: Secteur = {sector}")
        return sector
    except Exception as e:
        print(f"âš ï¸ Erreur pour {symbol}: {e}")
        return 'â„¹ï¸Inconnu!!'

def optimize_sector_coefficients(sector_symbols, domain, period='1y', n_iterations=20, montant=50, transaction_cost=1.0, 
                                initial_thresholds=(4.20, -0.5), max_cycles=2, convergence_threshold=0.1):
    """Optimise les coefficients et seuils en quatre Ã©tapes (initiale + trois itÃ©ratives) via recherche alÃ©atoire"""
    if not sector_symbols:
        print(f"ğŸš« Secteur {domain} vide, ignorÃ©")
        return None, 0.0, 0.0, initial_thresholds
    
    stock_data = download_stock_data(sector_symbols, period=period)
    
    if not stock_data:
        print(f"ğŸš¨ Aucune donnÃ©e tÃ©lÃ©chargÃ©e pour le secteur {domain}")
        return None, 0.0, 0.0, initial_thresholds
    
    for symbol, data in stock_data.items():
        print(f"ğŸ“Š {symbol}: {len(data['Close'])} points de donnÃ©es")
    
    best_gain_total = -float('inf')
    best_coeffs = None
    best_thresholds = initial_thresholds
    best_success_rate = 0.0
    best_trades = 0
    
    # Ã‰tape initiale : Optimiser coefficients, seuil_achat, et seuil_vente simultanÃ©ment
    print(f"ğŸ” Ã‰tape initiale : Optimisation globale pour {domain}")
    tested_configs = deque(maxlen=60)
    doublons = 0
    
    with tqdm(total=n_iterations, desc=f"ğŸ” Ã‰tape initiale - Global {domain}", unit="it") as pbar:
        for _ in range(n_iterations):
            coeffs = tuple(np.round(np.random.uniform(0.5, 3.0, 8), 2))
            seuil_achat = np.round(np.random.uniform(2.0, 6.0), 2)
            seuil_vente = np.round(np.random.uniform(-3.0, 0.0), 2)
            config_key = (coeffs, seuil_achat, seuil_vente)
            
            if config_key in tested_configs:
                doublons += 1
                continue
            tested_configs.append(config_key)
            
            total_gain = 0.0
            total_trades = 0
            total_success = 0
            
            for symbol, data in stock_data.items():
                prices = data['Close']
                volumes = data['Volume']
                
                result = backtest_signals(
                    prices, volumes, domain,
                    domain_coeffs={domain: coeffs},
                    seuil_achat=seuil_achat, seuil_vente=seuil_vente,
                    montant=montant, transaction_cost=transaction_cost
                )
                
                total_gain += result['gain_total']
                total_trades += result['trades']
                total_success += result['gagnants']
            
            avg_gain = total_gain / len(stock_data) if stock_data else 0.0
            success_rate = (total_success / total_trades * 100) if total_trades > 0 else 0.0
            if _ == 0:
                print(f"ğŸ” Ã‰tape initiale - Optimisation {domain} dÃ©marrÃ©e avec {len(stock_data)} symboles")
                print(f"ğŸ“ˆ ItÃ©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de rÃ©ussite = {success_rate:.2f}%")
            
            if avg_gain > best_gain_total:
                best_gain_total = avg_gain
                best_coeffs = coeffs
                best_thresholds = (seuil_achat, seuil_vente)
                best_success_rate = success_rate
                best_trades = total_trades
                pbar.set_postfix({
                    'Gain_moy': f"{best_gain_total:.2f}",
                    'Success_Rate': f"{success_rate:.2f}%",
                    'Seuil_Achat': f"{seuil_achat:.2f}",
                    'Seuil_Vente': f"{seuil_vente:.2f}",
                    'Trades': total_trades
                })
            
            pbar.update(1)
        
        print(f"ğŸ“Š Ã‰tape initiale - Nombre de doublons Ã©vitÃ©s : {doublons}")
    
    if best_coeffs is None:
        print(f"ğŸš¨ Ã‰tape initiale - Aucun coefficient optimisÃ© pour {domain}: aucun signal ACHAT/VENTE gÃ©nÃ©rÃ©")
        return None, 0.0, 0.0, initial_thresholds
    
    print(f"âœ… Ã‰tape initiale - Meilleurs coefficients : {best_coeffs}, Seuils : {best_thresholds}, Gain moyen = {best_gain_total:.2f}")
    
    # Boucle itÃ©rative pour les trois Ã©tapes
    cycle = 0
    while cycle < max_cycles:
        print(f"\nğŸ”„ Cycle {cycle + 1}/{max_cycles} pour {domain}")
        
        # Ã‰tape 1 : Optimiser les coefficients avec seuils fixes
        print(f"ğŸ” Ã‰tape 1 : Optimisation des coefficients avec seuils {best_thresholds}")
        current_gain_total = -float('inf')
        current_coeffs = best_coeffs
        current_success_rate = best_success_rate
        current_trades = best_trades
        tested_configs = deque(maxlen=60)
        doublons = 0
        
        with tqdm(total=n_iterations, desc=f"ğŸ” Cycle {cycle + 1} - Ã‰tape 1 - Coeffs {domain}", unit="it") as pbar:
            for _ in range(n_iterations):
                coeffs = tuple(np.round(np.random.uniform(0.5, 3.0, 8), 2))
                config_key = coeffs
                
                if config_key in tested_configs:
                    doublons += 1
                    continue
                tested_configs.append(config_key)
                
                total_gain = 0.0
                total_trades = 0
                total_success = 0
                
                for symbol, data in stock_data.items():
                    prices = data['Close']
                    volumes = data['Volume']
                    
                    result = backtest_signals(
                        prices, volumes, domain,
                        domain_coeffs={domain: coeffs},
                        seuil_achat=best_thresholds[0], seuil_vente=best_thresholds[1],
                        montant=montant, transaction_cost=transaction_cost
                    )
                    
                    total_gain += result['gain_total']
                    total_trades += result['trades']
                    total_success += result['gagnants']
                
                avg_gain = total_gain / len(stock_data) if stock_data else 0.0
                success_rate = (total_success / total_trades * 100) if total_trades > 0 else 0.0
                if _ == 0:
                    print(f"ğŸ” Cycle {cycle + 1} - Ã‰tape 1 - Optimisation {domain} dÃ©marrÃ©e avec {len(stock_data)} symboles")
                    print(f"ğŸ“ˆ ItÃ©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de rÃ©ussite = {success_rate:.2f}%")
                
                if avg_gain > current_gain_total:
                    current_gain_total = avg_gain
                    current_coeffs = coeffs
                    current_success_rate = success_rate
                    current_trades = total_trades
                    pbar.set_postfix({
                        'Gain_moy': f"{current_gain_total:.2f}",
                        'Success_Rate': f"{success_rate:.2f}%",
                        'Trades': total_trades
                    })
                
                pbar.update(1)
            
            print(f"ğŸ“Š Cycle {cycle + 1} - Ã‰tape 1 - Nombre de doublons Ã©vitÃ©s : {doublons}")
        
        if current_coeffs is None:
            print(f"ğŸš¨ Cycle {cycle + 1} - Ã‰tape 1 - Aucun coefficient optimisÃ© pour {domain}: aucun signal ACHAT/VENTE gÃ©nÃ©rÃ©")
            return None, 0.0, 0.0, best_thresholds
        
        print(f"âœ… Cycle {cycle + 1} - Ã‰tape 1 - Meilleurs coefficients : {current_coeffs}, Gain moyen = {current_gain_total:.2f}")
        
        # Ã‰tape 2 : Optimiser le seuil d'achat avec coefficients et seuil de vente fixes
        print(f"ğŸ” Ã‰tape 2 : Optimisation du seuil d'achat avec coefficients {current_coeffs} et seuil de vente {best_thresholds[1]}")
        tested_configs = deque(maxlen=60)
        doublons = 0
        current_seuil_achat = best_thresholds[0]
        
        with tqdm(total=n_iterations, desc=f"ğŸ” Cycle {cycle + 1} - Ã‰tape 2 - Seuil Achat {domain}", unit="it") as pbar:
            for _ in range(n_iterations):
                seuil_achat = np.round(np.random.uniform(2.0, 6.0), 2)
                config_key = seuil_achat
                
                if config_key in tested_configs:
                    doublons += 1
                    continue
                tested_configs.append(config_key)
                
                total_gain = 0.0
                total_trades = 0
                total_success = 0
                
                for symbol, data in stock_data.items():
                    prices = data['Close']
                    volumes = data['Volume']
                    
                    result = backtest_signals(
                        prices, volumes, domain,
                        domain_coeffs={domain: current_coeffs},
                        seuil_achat=seuil_achat, seuil_vente=best_thresholds[1],
                        montant=montant, transaction_cost=transaction_cost
                    )
                    
                    total_gain += result['gain_total']
                    total_trades += result['trades']
                    total_success += result['gagnants']
                
                avg_gain = total_gain / len(stock_data) if stock_data else 0.0
                success_rate = (total_success / total_trades * 100) if total_trades > 0 else 0.0
                if _ == 0:
                    print(f"ğŸ” Cycle {cycle + 1} - Ã‰tape 2 - Optimisation {domain} dÃ©marrÃ©e avec {len(stock_data)} symboles")
                    print(f"ğŸ“ˆ ItÃ©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de rÃ©ussite = {success_rate:.2f}%")
                
                if avg_gain > current_gain_total:
                    current_gain_total = avg_gain
                    current_seuil_achat = seuil_achat
                    current_success_rate = success_rate
                    current_trades = total_trades
                    pbar.set_postfix({
                        'Gain_moy': f"{current_gain_total:.2f}",
                        'Success_Rate': f"{success_rate:.2f}%",
                        'Seuil_Achat': f"{seuil_achat:.2f}",
                        'Trades': total_trades
                    })
                
                pbar.update(1)
            
            print(f"ğŸ“Š Cycle {cycle + 1} - Ã‰tape 2 - Nombre de doublons Ã©vitÃ©s : {doublons}")
        
        print(f"âœ… Cycle {cycle + 1} - Ã‰tape 2 - Meilleur seuil d'achat : {current_seuil_achat}, Gain moyen = {current_gain_total:.2f}")
        
        # Ã‰tape 3 : Optimiser le seuil de vente avec coefficients et seuil d'achat fixes
        print(f"ğŸ” Ã‰tape 3 : Optimisation du seuil de vente avec coefficients {current_coeffs} et seuil d'achat {current_seuil_achat}")
        tested_configs = deque(maxlen=60)
        doublons = 0
        current_seuil_vente = best_thresholds[1]
        
        with tqdm(total=n_iterations, desc=f"ğŸ” Cycle {cycle + 1} - Ã‰tape 3 - Seuil Vente {domain}", unit="it") as pbar:
            for _ in range(n_iterations):
                seuil_vente = np.round(np.random.uniform(-3.0, 0.0), 2)
                config_key = seuil_vente
                
                if config_key in tested_configs:
                    doublons += 1
                    continue
                tested_configs.append(config_key)
                
                total_gain = 0.0
                total_trades = 0
                total_success = 0
                
                for symbol, data in stock_data.items():
                    prices = data['Close']
                    volumes = data['Volume']
                    
                    result = backtest_signals(
                        prices, volumes, domain,
                        domain_coeffs={domain: current_coeffs},
                        seuil_achat=current_seuil_achat, seuil_vente=seuil_vente,
                        montant=montant, transaction_cost=transaction_cost
                    )
                    
                    total_gain += result['gain_total']
                    total_trades += result['trades']
                    total_success += result['gagnants']
                
                avg_gain = total_gain / len(stock_data) if stock_data else 0.0
                success_rate = (total_success / total_trades * 100) if total_trades > 0 else 0.0
                if _ == 0:
                    print(f"ğŸ” Cycle {cycle + 1} - Ã‰tape 3 - Optimisation {domain} dÃ©marrÃ©e avec {len(stock_data)} symboles")
                    print(f"ğŸ“ˆ ItÃ©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de rÃ©ussite = {success_rate:.2f}%")
                
                if avg_gain > current_gain_total:
                    current_gain_total = avg_gain
                    current_seuil_vente = seuil_vente
                    current_success_rate = success_rate
                    current_trades = total_trades
                    pbar.set_postfix({
                        'Gain_moy': f"{current_gain_total:.2f}",
                        'Success_Rate': f"{success_rate:.2f}%",
                        'Seuil_Vente': f"{seuil_vente:.2f}",
                        'Trades': total_trades
                    })
                
                pbar.update(1)
            
            print(f"ğŸ“Š Cycle {cycle + 1} - Ã‰tape 3 - Nombre de doublons Ã©vitÃ©s : {doublons}")
        
        current_thresholds = (current_seuil_achat, current_seuil_vente)
        print(f"âœ… Cycle {cycle + 1} - Ã‰tape 3 - Meilleur seuil de vente : {current_seuil_vente}, Gain moyen = {current_gain_total:.2f}")
        
        # Mise Ã  jour des meilleurs paramÃ¨tres
        if current_gain_total > best_gain_total:
            improvement = current_gain_total - best_gain_total
            best_gain_total = current_gain_total
            best_coeffs = current_coeffs
            best_thresholds = current_thresholds
            best_success_rate = current_success_rate
            best_trades = current_trades
            print(f"âœ… Cycle {cycle + 1} - AmÃ©lioration du gain : {improvement:.2f}")
            save_optimization_results(domain, best_coeffs, best_gain_total, best_success_rate, best_trades, best_thresholds)
        else:
            print(f"âœ… Cycle {cycle + 1} - Aucune amÃ©lioration significative, arrÃªt anticipÃ©")
            break
        
        # CritÃ¨re de convergence
        if cycle > 0 and improvement < convergence_threshold:
            print(f"âœ… Cycle {cycle + 1} - Convergence atteinte (amÃ©lioration < {convergence_threshold})")
            break
        
        cycle += 1
    
    if best_coeffs is None:
        print(f"ğŸš¨ Aucun coefficient optimisÃ© pour {domain}: aucun signal ACHAT/VENTE gÃ©nÃ©rÃ©")
    else:
        save_optimization_results(domain, best_coeffs, best_gain_total, best_success_rate, best_trades, best_thresholds)
    
    return best_coeffs, best_gain_total, best_success_rate, best_thresholds


def save_optimization_results(domain, coeffs, gain_total, success_rate, total_trades, thresholds):
    """Sauvegarde les rÃ©sultats dans un CSV, Ã©vitant les doublons"""
    results = {
        'Timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'Sector': domain,
        'Gain_moy': gain_total,
        'Success_Rate': success_rate,
        'Trades': total_trades,
        'Seuil_Achat': thresholds[0],
        'Seuil_Vente': thresholds[1],
        'a1': coeffs[0], 'a2': coeffs[1], 'a3': coeffs[2], 'a4': coeffs[3],
        'a5': coeffs[4], 'a6': coeffs[5], 'a7': coeffs[6], 'a8': coeffs[7]
    }
    df_new = pd.DataFrame([results])
    csv_path = 'signaux/optimization_hist_4stp.csv'
    
    try:
        if pd.io.common.file_exists(csv_path):
            df_existing = pd.read_csv(csv_path)
            # VÃ©rifier si la derniÃ¨re entrÃ©e pour le secteur est identique
            last_entry = df_existing[df_existing['Sector'] == domain].tail(1)
            if not last_entry.empty:
                same_params = (
                    (last_entry['Gain_moy'].iloc[0] == gain_total) and
                    (last_entry['Success_Rate'].iloc[0] == success_rate) and
                    (last_entry['Trades'].iloc[0] == total_trades) and
                    (last_entry['Seuil_Achat'].iloc[0] == thresholds[0]) and
                    (last_entry['Seuil_Vente'].iloc[0] == thresholds[1]) and
                    all(last_entry[f'a{i+1}'].iloc[0] == coeffs[i] for i in range(8))
                )
                if same_params:
                    print(f"ğŸ“ EntrÃ©e identique pour {domain}, sauvegarde ignorÃ©e")
                    return
        df_new.to_csv(csv_path, mode='a', header=not pd.io.common.file_exists(csv_path), index=False)
        print(f"ğŸ“ RÃ©sultats sauvegardÃ©s pour {domain}")
    except Exception as e:
        print(f"âš ï¸ Erreur lors de la sauvegarde dans le CSV: {e}")

# Exemple d'utilisation
if __name__ == "__main__":
    # Exemple de symboles par secteur, incluant cryptomonnaies et inconnus
    symbols = list(dict.fromkeys(load_symbols_from_txt("optimisation_symbols.txt")))
    # CrÃ©er le dictionnaire des secteurs dynamiquement
    sectors = {
        "Technology": [],
        "Healthcare": [],  
        "Financial Services":[],
        "Consumer Cyclical":  [],
        "Industrials":     [],
        "Energy":          [],
        "Basic Materials": [],
        "Communication Services": [],
        "Consumer Defensive": [],
        "Utilities":      [],
        "Real Estate":  [],
        "â„¹ï¸Inconnu!!": []
    }
    
    # Assigner les symboles aux secteurs
    for symbol in symbols:
        sector = get_sector(symbol)
        if sector in sectors:
            sectors[sector].append(symbol)
        else:
            sectors["â„¹ï¸Inconnu!!"].append(symbol)
    
    print("\nğŸ“‹ Assignation des secteurs:")
    for sector, syms in sectors.items():
        print(f"{sector}: {syms}")
    
    optimized_coeffs = {}
    for sector, sector_symbols in sectors.items():
        if not sector_symbols:
            print(f"ğŸš« Secteur {sector} vide, ignorÃ©")
            continue
        coeffs, gain_total, success_rate, thresholds = optimize_sector_coefficients(
            sector_symbols, sector, period='1y', n_iterations=10, montant=50, 
            transaction_cost=0.02, max_cycles=255, convergence_threshold=0.1
        )
        if coeffs:
            optimized_coeffs[sector] = coeffs
            print(f"\nSecteur: {sector}")
            print(f"Meilleurs coefficients: {coeffs}")
            print(f"Meilleurs seuils (achat, vente): {thresholds}")
            print(f"Gain total moyen: {gain_total:.2f}")
            print(f"Taux de rÃ©ussite: {success_rate:.2f}%")
            print(f"\n")
    
    print("Dictionnaire optimisÃ© pour domain_coeffs:")
    print("{")
    for sector, coeffs in optimized_coeffs.items():
        print(f"    '{sector}': {coeffs},")
    print("}")