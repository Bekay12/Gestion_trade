import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import random
from qsi import backtest_signals,download_stock_data,modify_symbols_file,load_symbols_from_txt
from pathlib import Path
from tqdm import tqdm
import yfinance as yf
from collections import deque

def get_sector(symbol):
    """R√©cup√®re le secteur d'une action avec logs pour diagnostic"""
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info
        sector = info.get('sector', '‚ÑπÔ∏èInconnu!!')
        print(f"üìã {symbol}: Secteur = {sector}")
        return sector
    except Exception as e:
        print(f"‚ö†Ô∏è Erreur pour {symbol}: {e}")
        return '‚ÑπÔ∏èInconnu!!'

def optimize_sector_coefficients(sector_symbols, domain, period='1y', n_iterations=100, montant=50, transaction_cost=1.0):
    """Optimise les coefficients pour un secteur donn√© via recherche al√©atoire en utilisant download_stock_data"""
    if not sector_symbols:
        print(f"üö´ Secteur {domain} vide, ignor√©")
        return None, 0.0, (4.20, -0.5)
    
    stock_data = download_stock_data(sector_symbols, period=period)
    
    if not stock_data:
        print(f"üö® Aucune donn√©e t√©l√©charg√©e pour le secteur {domain}")
        return None, 0.0, (4.20, -0.5)
    
    for symbol, data in stock_data.items():
        print(f"üìä {symbol}: {len(data['Close'])} points de donn√©es")
    
    best_gain_total = -float('inf')  # Optimiser sur le gain total
    best_coeffs = None
    best_thresholds = (4.20, -0.5)
    tested_configs = deque(maxlen=80)  # Ensemble pour stocker les configurations test√©es
    
    # Barre de progression principale avec tqdm
    with tqdm(total=n_iterations, desc=f"üîç Optimisation {domain}", unit="it") as pbar:   
        for _ in range(n_iterations):
            # G√©n√©rer des coefficients arrondis √† 2 chiffres apr√®s la virgule
            coeffs = tuple(np.round(np.random.uniform(0.5, 3.0, 8), 2))
            seuil_achat = np.round(np.random.uniform(2.0, 5.0), 2)
            seuil_vente = np.round(np.random.uniform(-2.0, 0.0), 2)

            # V√©rifier si la configuration a d√©j√† √©t√© test√©e
            config_key = (coeffs, seuil_achat, seuil_vente)
            if config_key in tested_configs:
                continue  # Passer √† la prochaine it√©ration si doublon
            tested_configs.append(config_key)

            total_gain = 0.0
            total_trades = 0
            total_success = 0
            success_rate = 0.0
            
            for symbol, data in stock_data.items():
                prices = data['Close']
                volumes = data['Volume']
                
                result = backtest_signals(
                    prices, volumes, domain,
                    domain_coeffs={domain: coeffs},
                    montant=montant , transaction_cost=transaction_cost,
                    seuil_achat=seuil_achat, seuil_vente=seuil_vente
                )

                total_gain += result['gain_total']
                total_trades += result['trades']
                total_success += result['gagnants']
                success_rate = (total_success / total_trades) * 100 if total_trades > 0 else 0.0
                    
            avg_gain = total_gain / len(stock_data) if stock_data else 0.0
            if _ == 0:
                print(f"üîç Optimisation {domain} d√©marr√©e avec {len(stock_data)} symboles")
                print(f"üìà It√©ration 1: Gain moyen = {avg_gain:.2f}, Trades = {total_trades}, Taux de r√©ussite = {success_rate:.2f}% ,")
            
            if avg_gain > best_gain_total:
                best_gain_total = avg_gain
                best_coeffs = coeffs
                best_thresholds = (seuil_achat, seuil_vente)
                pbar.set_postfix({
                    'Mean_Gain': f"{best_gain_total:.2f}",
                    'Success_Rate': f"{success_rate:.2f}%",
                    'Seuil_Achat': f"{seuil_achat:.2f}",
                    'Seuil_Vente': f"{seuil_vente:.2f}",
                    'Trades': total_trades
                })

                save_optimization_results(domain, best_coeffs,best_gain_total, success_rate,total_trades, best_thresholds)
            pbar.update(1)

    if best_coeffs is None:
        print(f"üö® Aucun coefficient optimis√© pour {domain}: aucun signal ACHAT/VENTE g√©n√©r√©")

    return best_coeffs, best_gain_total, success_rate, best_thresholds

def save_optimization_results(sector, coeffs,gain_total, success_rate, trade, thresholds, filename="signaux/optimization_history.csv"):
    """Enregistre les r√©sultats de l'optimisation dans un CSV √©volutif"""
    file_path = Path(filename)
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Cr√©er une ligne pour le CSV
    row = {
        'Timestamp': timestamp,
        'Sector': sector,
        'Mean_Gain': round(gain_total, 2),
        'Success_Rate': round(success_rate, 4),
        'Trades': trade,
        'Seuil_Achat': round(thresholds[0], 2),
        'Seuil_Vente': round(thresholds[1], 2),
        'a1': round(coeffs[0], 3),
        'a2': round(coeffs[1], 3),
        'a3': round(coeffs[2], 3),
        'a4': round(coeffs[3], 3),
        'a5': round(coeffs[4], 3),
        'a6': round(coeffs[5], 3),
        'a7': round(coeffs[6], 3),
        'a8': round(coeffs[7], 3)
    }
    
    # Convertir en DataFrame
    df_new = pd.DataFrame([row])
    
    # Si le fichier existe, ajouter les donn√©es
    if file_path.exists():
        try:
            df_old = pd.read_csv(file_path)
            df_combined = pd.concat([df_old, df_new], ignore_index=True)
        except Exception as e:
            print(f"‚ö†Ô∏è Erreur lecture CSV: {e}")
            df_combined = df_new
    else:
        df_combined = df_new
    
    # Cr√©er le dossier 'signaux' si n√©cessaire
    file_path.parent.mkdir(parents=True, exist_ok=True)
    
    # Sauvegarder
    try:
        df_combined.to_csv(file_path, index=False)
        print(f"üíæ R√©sultats enregistr√©s dans {file_path}")
    except Exception as e:
        print(f"üö® Erreur sauvegarde CSV: {e}")

# Exemple d'utilisation
if __name__ == "__main__":
    # Exemple de symboles par secteur, incluant cryptomonnaies et inconnus
    symbols = list(dict.fromkeys(load_symbols_from_txt("optimisation_symbols.txt")))
    # Cr√©er le dictionnaire des secteurs dynamiquement
    sectors = {
        "Technology": [],
        "Healthcare": [],  
        "Financial Services":[],
        "Consumer Cyclical":  [],
        "Industrials":     [],
        "Energy":          [],
        "Basic Materials": [],
        "Communication Services": [],
        "Utilities":      [],
        "Real Estate":  [],
        "‚ÑπÔ∏èInconnu!!": []
    }
    
    # Assigner les symboles aux secteurs
    for symbol in symbols:
        sector = get_sector(symbol)
        if sector in sectors:
            sectors[sector].append(symbol)
        else:
            sectors["‚ÑπÔ∏èInconnu!!"].append(symbol)

    optimized_coeffs = {}
    for sector, sector_symbols in sectors.items():
        if not sector_symbols:
            print(f"üö´ Secteur {sector} vide, ignor√©")
            continue
        coeffs, gain_total, thresholds,*_ = optimize_sector_coefficients(
            sector_symbols, sector, period='1y',n_iterations=350, montant=50, transaction_cost=0.00
        )
        if coeffs:
            optimized_coeffs[sector] = coeffs
            print(f"\nSecteur: {sector}")
            print(f"Meilleurs coefficients: {coeffs}")
            print(f"Meilleurs seuils (achat, vente): {thresholds}")
            print(f"Gain total moyen: {gain_total:.2f}\n")
    
    # G√©n√©rer le dictionnaire Python
    print("Dictionnaire optimis√© pour domain_coeffs:")
    print("{")
    for sector, coeffs in optimized_coeffs.items():
        print(f"    '{sector}': {coeffs},")
    print("}")