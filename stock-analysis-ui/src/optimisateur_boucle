from qsi import download_stock_data, analyse_signaux_populaires, get_trading_signal, popular_symbols, mes_symbols, period
import numpy as np
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import ta
import time
import csv
import itertools
from tqdm import tqdm


def get_sector(symbol):
    """R√©cup√®re le secteur d'une action"""
    try:
        ticker = yf.Ticker(symbol)
        return ticker.info.get('sector', 'Unknown')
    except:
        return 'Unknown'

def evaluate_simple(symbols, seuil_achat, seuil_vente, rsi_window, macd_fast):
    """√âvaluation rapide sur un sous-ensemble"""
    correct = 0
    total = 0
    
    for symbol in symbols:
        data = download_stock_data([symbol], "12mo")[symbol]
        prices = data['Close']
        volumes = data['Volume']
        domaine = get_sector(symbol)
        
        # G√©n√©rer signal avec param√®tres actuels
        signal = get_trading_signal(
            prices, volumes, domaine,
            seuil_achat=seuil_achat,
            seuil_vente=seuil_vente,
        )[0]
        
        # √âvaluer la performance √† 5 jours
        future_5d = (prices.iloc[-1] - prices.iloc[-6]) / prices.iloc[-6]
        
        if signal == "ACHAT" and future_5d > 0.02:
            correct += 1
        elif signal == "VENTE" and future_5d < -0.02:
            correct += 1
            
        total += 1
    
    return correct / total if total > 0 else 0



def optimize_sector_coefficients(symbols_sample, n_iter=50):
    """Optimisation des coefficients par secteur avec recherche al√©atoire"""
    # Liste de tous les secteurs
    all_sectors = [
        "Technology", "Healthcare", "Financial Services", 
        "Consumer Cyclical", "Industrials", "Energy",
        "Basic Materials", "Communication Services", 
        "Utilities", "Real Estate"
    ]
    
    # Plages de valeurs pour les coefficients
    coeff_range = np.linspace(0.5, 3.0, 10)  # 10 valeurs entre 0.5 et 3.0
    
    best_accuracy = 0
    best_coeffs = None
    best_seuils = None
    
    # Barre de progression principale
    with tqdm(total=n_iter, desc="üîç Optimisation sectorielle", unit="it") as pbar:
        for i in range(n_iter):
            # G√©n√©rer une configuration al√©atoire pour tous les secteurs
            random_coeffs = {}
            for sector in all_sectors:
                # G√©n√©rer 8 coefficients al√©atoires pour ce secteur
                random_coeffs[sector] = tuple(np.random.choice(coeff_range, size=8))
            
            # G√©n√©rer des seuils al√©atoires
            random_seuil_achat = np.random.uniform(4.0, 6.0)
            random_seuil_vente = np.random.uniform(-3.0, -0.5)
            
            try:
                accuracy = evaluate_sector_coefficients(
                    symbols_sample,
                    random_coeffs,
                    random_seuil_achat,
                    random_seuil_vente
                )
                
                if accuracy > best_accuracy:
                    best_accuracy = accuracy
                    best_coeffs = random_coeffs
                    best_seuils = (random_seuil_achat, random_seuil_vente)
                    pbar.set_postfix({'best_acc': f"{best_accuracy:.2%}"})
                    
            except Exception as e:
                pbar.set_postfix({'error': str(e)[:20] + '...'})
            
            pbar.update(1)
    
    return best_coeffs, best_seuils, best_accuracy

    # Configuration initiale des coefficients
base_coeffs = {
        "Technology": (2.0, 1.5, 1.3, 1.5, 1.8, 1.5, 1.4, 1.2),
        "Healthcare": (1.8, 1.1, 1.6, 1.3, 1.8, 1.3, 1.3, 1.8),
        "Financial Services": (1.6, 1.9, 2.3, 1.2, 1.6, 1.1, 1.2, 1.6),
        "Consumer Cyclical": (1.7, 1.0, 1.4, 1.2, 1.7, 1.2, 1.7, 1.7),
        "Industrials": (1.7, 1.2, 1.2, 1.0, 1.5, 1.0, 1.2, 1.5),
        "Energy": (1.4, 1.7, 1.1, 1.1, 1.4, 0.9, 0.7, 1.4),
        "Basic Materials": (1.3, 1.6, 1.0, 1.8, 1.3, 0.8, 0.6, 1.3),
        "Communication Services": (1.6, 1.0, 1.3, 1.1, 1.6, 1.1, 1.0, 1.6),
        "Utilities": (1.8, 1.5, 1.2, 1.3, 1.2, 1.3, 0.5, 1.2),
        "Real Estate": (1.1, 1.6, 1.2, 1.4, 1.1, 1.4, 0.4, 1.1)
    }
def grid_search_sector_coefficients(symbols_sample):
    # Espace de recherche
    variations = [0.8, 1.0, 1.2]
    seuils_achat = [4.5, 5.0, 5.5]
    seuils_vente = [-1.0, -2.0, -3.0]
    
    best_accuracy = 0
    best_config = None
    total_combinations = len(variations)**3 * len(seuils_achat) * len(seuils_vente)
    
    with tqdm(total=total_combinations, desc="üîç Recherche sectorielle", unit="comb") as pbar:
        for v1, v2, v3 in itertools.product(variations, repeat=3):
            new_coeffs = {}
            for sector, coeffs in base_coeffs.items():
                new_coeffs[sector] = tuple(c * v for c, v in zip(coeffs, (v1, v2, v3, v1, v2, v3, v1, v2)))
            
            for seuil_achat in seuils_achat:
                for seuil_vente in seuils_vente:
                    try:
                        accuracy = evaluate_sector_coefficients(
                            symbols_sample,
                            new_coeffs,
                            seuil_achat,
                            seuil_vente
                        )
                        
                        # Gestion des configurations non valides
                        if accuracy is None:
                            continue
                            
                        if accuracy > best_accuracy:
                            best_accuracy = accuracy
                            best_config = {
                                'coeffs': new_coeffs,
                                'seuil_achat': seuil_achat,
                                'seuil_vente': seuil_vente
                            }
                            pbar.set_postfix({'best_acc': f"{best_accuracy:.2%}"})
                            
                    except Exception as e:
                        continue
                    
                    pbar.update(1)
    
    # Fallback si aucune config valide
    if best_config is None:
        print("‚ö†Ô∏è Aucune configuration optimale trouv√©e. Utilisation des param√®tres par d√©faut.")
        return base_coeffs, (5.0, -2.0), 0.0
    
    return best_config['coeffs'], (best_config['seuil_achat'], best_config['seuil_vente']), best_accuracy

def evaluate_sector_coefficients(symbols, sector_coeffs, seuil_achat, seuil_vente):
    """√âvalue une configuration de coefficients sectoriels avec gestion des erreurs"""
    if not symbols:
        return None
        
    correct = 0
    total = 0
    
    for symbol in symbols:
        try:
            data = download_stock_data([symbol], "6mo").get(symbol)
            if data is None or len(data) < 6:
                continue
                
            prices = data['Close']
            volumes = data['Volume']
            secteur = get_sector(symbol)
            
            signal = get_trading_signal(
                prices, volumes, secteur,
                domain_coeffs=sector_coeffs,
                seuil_achat=seuil_achat,
                seuil_vente=seuil_vente
            )[0]
            
            if len(prices) > 5:
                future_5d = (prices.iloc[-1] - prices.iloc[-6]) / prices.iloc[-6]
                
                if signal == "ACHAT" and future_5d > 0.02:
                    correct += 1
                elif signal == "VENTE" and future_5d < -0.02:
                    correct += 1
                    
                total += 1
                
        except Exception as e:
            continue
    
    return correct / total if total > 5 else None  # N√©cessite au moins 5 √©valuations valides

# Fonction pour appliquer les coefficients optimis√©s
def apply_optimized_coeffs(optimized_coeffs):
    """Applique les coefficients optimis√©s dans le code principal"""
    print("\n‚úÖ Coefficients optimis√©s par secteur:")
    for sector, coeffs in optimized_coeffs.items():
        print(f"{sector}: {coeffs}")
    return optimized_coeffs

def display_optimization_results(best_coeffs, best_seuils, best_accuracy):
    """Affiche les r√©sultats de l'optimisation de mani√®re lisible"""
    # En-t√™te
    print("\n" + "="*70)
    print("üî• R√âSULTATS DE L'OPTIMISATION SECTORIELLE")
    print("="*70)
    
    # Affichage de la pr√©cision
    print(f"\nüéØ PR√âCISION OPTIMIS√âE: {best_accuracy:.2%}\n")
    
    # Affichage des seuils
    seuil_achat, seuil_vente = best_seuils
    print("‚öñÔ∏è SEUILS OPTIMAUX:")
    print(f"- Seuil ACHAT: {seuil_achat:.2f}")
    print(f"- Seuil VENTE: {seuil_vente:.2f}")
    print("-"*50)
    
    # Affichage des coefficients par secteur
    print("\nüìä COEFFICIENTS OPTIMIS√âS PAR SECTEUR:")
    print("Secteur               a1     a2     a3     a4     a5     a6     a7     a8")
    print("-"*70)
    
    for sector, coeffs in best_coeffs.items():
        # Formatage des coefficients
        formatted_coeffs = [f"{c:.3f}" for c in coeffs]
        # Affichage align√©
        print(f"{sector[:20]:<20} {formatted_coeffs[0]:>6} {formatted_coeffs[1]:>6} {formatted_coeffs[2]:>6} "
              f"{formatted_coeffs[3]:>6} {formatted_coeffs[4]:>6} {formatted_coeffs[5]:>6} "
              f"{formatted_coeffs[6]:>6} {formatted_coeffs[7]:>6}")
    
    # Pied de page
    print("\n" + "="*70)
    print("="*70)

# Exemple d'utilisation apr√®s l'optimisation
if __name__ == "__main__":
    # Ex√©cution de l'optimisation
    best_coeffs, best_seuils, best_accuracy = grid_search_sector_coefficients(mes_symbols[:15])
    
    # Affichage des r√©sultats
    display_optimization_results(best_coeffs, best_seuils, best_accuracy)
    
    # G√©n√©ration d'un dictionnaire Python pr√™t √† l'emploi
    print("\nüìù DICTIONNAIRE PYTHON PR√äT √Ä COPIER-COLLER:")
    print("domain_coeffs = {")
    for sector, coeffs in best_coeffs.items():
        coeffs_str = ", ".join([f"{c:.3f}" for c in coeffs])
        print(f'    "{sector}": ({coeffs_str}),')
    print("}")
    
    # 1. V√©rifier la disponibilit√© des donn√©es
    valid_symbols = []
    for symbol in mes_symbols[:15]:
        try:
            data = download_stock_data([symbol], "6mo")[symbol]
            if len(data) > 20:  # V√©rifier suffisamment de donn√©es
                valid_symbols.append(symbol)
        except:
            continue
    
    if not valid_symbols:
        print("‚ùå Aucun symbole valide pour l'optimisation")
        exit()
    
    print(f"üîç Utilisation de {len(valid_symbols)} symboles valides pour l'optimisation")
    
    # 2. Ex√©cuter l'optimisation avec gestion des erreurs
    try:
        best_coeffs, best_seuils, best_accuracy = grid_search_sector_coefficients(valid_symbols)
    except Exception as e:
        print(f"‚ùå Erreur lors de l'optimisation: {e}")
        best_coeffs = base_coeffs  # Utiliser la config de base
        best_seuils = (5.0, -2.0)
        best_accuracy = 0.0

    # 3. Affichage des r√©sultats
    print("\nüîé Optimisation termin√©e!")
    print(f"- Meilleure pr√©cision: {best_accuracy:.2%}")
    print(f"- Seuil achat: {best_seuils[0]:.2f}")
    print(f"- Seuil vente: {best_seuils[1]:.2f}")
    
    # 4. Application des r√©sultats
    domain_coeffs = apply_optimized_coeffs(best_coeffs)
    print("\nüîß Coefficients appliqu√©s dans le syst√®me.")