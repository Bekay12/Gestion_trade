import pandas as pd
import numpy as np
from datetime import datetime, timedelta
import random
from qsi import backtest_signals,download_stock_data,modify_symbols_file,load_symbols_from_txt, extract_best_parameters
from pathlib import Path
from tqdm import tqdm
import yfinance as yf
from collections import deque

def get_sector(symbol):
    """RÃ©cupÃ¨re le secteur d'une action avec logs pour diagnostic"""
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info
        sector = info.get('sector', 'â„¹ï¸Inconnu!!')
        print(f"ğŸ“‹ {symbol}: Secteur = {sector}")
        return sector
    except Exception as e:
        print(f"âš ï¸ Erreur pour {symbol}: {e}")
        return 'â„¹ï¸Inconnu!!'

def get_best_gain_csv(domain, csv_path='signaux/optimization_hist_4stp.csv'):
    """RÃ©cupÃ¨re le meilleur gain moyen historique pour le secteur dans le CSV."""
    try:
        if pd.io.common.file_exists(csv_path):
            df = pd.read_csv(csv_path)
            sector_data = df[df['Sector'] == domain]
            if not sector_data.empty:
                return sector_data['Gain_moy'].max()
    except Exception as e:
        print(f"âš ï¸ Erreur chargement CSV pour {domain}: {e}")
    return -float('inf')

def optimize_sector_coefficients(
        sector_symbols, domain,
        period='1y', n_iterations=20,
        montant=50, transaction_cost=1.0,
        initial_thresholds=(4.20, -0.5),
        max_cycles=2, convergence_threshold=0.1
    ):
    """Optimise coefficients et seuils en quatre Ã©tapes,
    en rÃ©fÃ©rence permanente au record historique et au record courant."""
    if not sector_symbols:
        print(f"ğŸš« Secteur {domain} vide, ignorÃ©")
        return None, 0.0, 0.0, initial_thresholds

    stock_data = download_stock_data(sector_symbols, period=period)
    if not stock_data:
        print(f"ğŸš¨ Aucune donnÃ©e tÃ©lÃ©chargÃ©e pour le secteur {domain}")
        return None, 0.0, 0.0, initial_thresholds

    for symbol, data in stock_data.items():
        print(f"ğŸ“Š {symbol}: {len(data['Close'])} points de donnÃ©es")

    csv_path = 'signaux/optimization_hist_4stp.csv'
    # Charger dâ€™un seul coup tous les meilleurs paramÃ¨tres historiques
    best_params_per_sector = extract_best_parameters(csv_path)

    # RÃ©cupÃ©rer pour le secteur courant
    if domain in best_params_per_sector:
        csv_coeffs, csv_thresholds, csv_gain = best_params_per_sector[domain]
    else:
        csv_coeffs, csv_thresholds, csv_gain = None, initial_thresholds, -float('inf')    
    best_success_rate = 0.0
    best_trades = 0
    global_best_gain  = csv_gain
    best_gain_total   = global_best_gain
    best_coeffs       = csv_coeffs
    best_thresholds   = csv_thresholds
    


    # Ã‰tape initiale : global + record CSV
    print(f"ğŸ” Ã‰tape initiale : Optimisation globale pour {domain}")
    tested_configs = deque(maxlen=60)
    doublons = 0
    with tqdm(total=n_iterations, desc=f"ğŸ” Initiale - Global {domain}", unit="it") as pbar:
        for i in range(n_iterations):
            coeffs = tuple(np.round(np.random.uniform(0.5, 3.0, 8), 2))
            seuil_achat = np.round(np.random.uniform(2.0, 6.0), 2)
            seuil_vente = np.round(np.random.uniform(-3.0, 0.0), 2)
            key = (coeffs, seuil_achat, seuil_vente)
            if key in tested_configs:
                doublons += 1
                continue
            tested_configs.append(key)

            tot_gain = tot_trades = tot_success = 0
            for data in stock_data.values():
                res = backtest_signals(
                    data['Close'], data['Volume'], domain,
                    domain_coeffs={domain: coeffs},
                    seuil_achat=seuil_achat, seuil_vente=seuil_vente,
                    montant=montant, transaction_cost=transaction_cost
                )
                tot_gain += res['gain_total']
                tot_trades += res['trades']
                tot_success += res['gagnants']

            avg_gain = tot_gain / len(stock_data)
            success_rate = (tot_success / tot_trades * 100) if tot_trades else 0.0
            if avg_gain > best_gain_total:
                best_gain_total = avg_gain
                best_coeffs = coeffs
                best_thresholds = (seuil_achat, seuil_vente)
                best_success_rate = success_rate
                best_trades = tot_trades
                if avg_gain > global_best_gain:
                    global_best_gain = avg_gain
                    print(f"ğŸ¯ Nouveau record global pour {domain}: Gain moyen = {avg_gain:.2f}")
                pbar.set_postfix({
                    'Gain_moy': f"{best_gain_total:.2f}",
                    'Success_Rate': f"{success_rate:.2f}%",
                    'Seuil_Achat': f"{seuil_achat:.2f}",
                    'Seuil_Vente': f"{seuil_vente:.2f}",
                    'Trades': tot_trades
                })
            pbar.update(1)
            
        print(f"ğŸ“Š Initiale - doublons Ã©vitÃ©s : {doublons}")
    if best_coeffs == csv_coeffs and best_thresholds == csv_thresholds:
        print(f"ğŸš¨ Aucune amÃ©lioration initiale pour {domain},Meilleurs coeffs : {best_coeffs}, seuils : {best_thresholds}, Gain moyen = {best_gain_total:.2f}")
    else:
        print(f"âœ… Initiale - Meilleurs coeffs : {best_coeffs}, seuils : {best_thresholds}, Gain moyen = {best_gain_total:.2f}")
    # Avant la boucle
    initial_coeffs = [None] * max_cycles
    cycle = 0
    
    achat_vals = np.linspace(2.0, 6.0, num=n_iterations)
    vente_vals = np.linspace(-3.0, 0.0, num=n_iterations)
    while cycle < max_cycles:
        print(f"\nğŸ”„ Cycle {cycle+1}/{max_cycles} pour {domain}")
        cycle_start_gain = global_best_gain
        cycle_start_gain = best_gain_total  # âœ… Correction: utiliser best_gain_total
        should_continue = True  # âœ… Flag pour gÃ©rer l'arrÃªt du cycle

        # Trois sous-Ã©tapes, chacune repartant de global_best_gain
        for step, (opt_keys, desc) in enumerate([
            ((True, True), "coeffs + seuil achat"),
            ((True, False), "coeffs fixes"),
            ((False, True), "seuil achat"),
            ((False, False), "seuil vente")
        ], start=1):
            
             # âœ… Sauvegarde APRÃˆS l'Ã©tape 1, pas avant l'Ã©tape 3
            if step == 3:
                initial_coeffs[cycle] = best_coeffs
                # VÃ©rification si on doit continuer
                if cycle > 0 and initial_coeffs[cycle] == initial_coeffs[cycle-1]:
                    print(f"â­ï¸ Coefficients inchangÃ©s depuis cycle {cycle}, skip Ã©tapes 2 & 3")
                    should_continue = False
                    break  # âœ… Sort de la boucle for
            
            if not should_continue:
                break
            print(f"ğŸ” Ã‰tape {step} : Optimisation {desc}")
            current_best = global_best_gain
            tested = deque(maxlen=60)
            doublons = 0

            with tqdm(total=n_iterations, desc=f"ğŸ” Cycle{cycle+1}-Etape{step}", unit="it") as pbar:
                
                for i in range(n_iterations):
                    if opt_keys == (True, True):
                        candidate = tuple(np.round(np.random.uniform(0.5, 3.0, 8), 2))
                        sa = np.round(np.random.uniform(2.0, 6.0), 2)
                        cfg = (candidate, sa)
                    elif opt_keys == (True, False):
                        # changer coeffs
                        candidate = tuple(np.round(np.random.uniform(0.5, 3.0, 8), 2))
                        cfg = candidate
                    elif opt_keys == (False, True):
                        candidate = achat_vals[i]
                    else:
                        candidate = vente_vals[i]
                    cfg = candidate

                    if cfg in tested:
                        doublons += 1
                        continue
                    tested.append(cfg)

                    tot_gain = tot_trades = tot_success = 0
                    for data in stock_data.values():
                        cfs = best_coeffs if not opt_keys[0] else candidate
                        sa = best_thresholds[0] if not opt_keys[1] else candidate
                        sv = best_thresholds[1] if opt_keys == (True, False) else best_thresholds[1]
                        if step == 3:
                            sa = best_thresholds[0]
                            sv = candidate
                        res = backtest_signals(
                            data['Close'], data['Volume'], domain,
                            domain_coeffs={domain: cfs},
                            seuil_achat=sa, seuil_vente=sv,
                            montant=montant, transaction_cost=transaction_cost
                        )
                        tot_gain += res['gain_total']
                        tot_trades += res['trades']
                        tot_success += res['gagnants']

                    avg_gain = tot_gain / len(stock_data)
                    success_rate = (tot_success / tot_trades * 100) if tot_trades else 0.0
                    if avg_gain > current_best:
                        current_best = avg_gain
                        if avg_gain > best_gain_total:
                            best_gain_total = avg_gain
                            if opt_keys[0]:
                                best_coeffs = candidate
                            elif opt_keys[1]:
                                best_thresholds = (candidate, best_thresholds[1])
                            else:
                                best_thresholds = (best_thresholds[0], candidate)
                            best_success_rate = success_rate
                            best_trades = tot_trades
                            if avg_gain > global_best_gain:
                                global_best_gain = avg_gain
                                print(f"ğŸ¯ Nouveau record global aprÃ¨s Ã©tape {step}: Gain moyen = {avg_gain:.2f}")
                        pbar.set_postfix({'Gain_moy': f"{avg_gain:.2f}", 'Trades': tot_trades})
                    pbar.update(1)
                print(f"ğŸ“Š Cycle{cycle+1}-Etape{step} doublons Ã©vitÃ©s : {doublons}")
                print(f"âœ… Ã‰tape {step} - Gain moyen = {current_best:.2f}")

        improvement = best_gain_total - cycle_start_gain
        if improvement <= convergence_threshold:
            print(f"âœ… Convergence atteinte ({improvement:.2f} â‰¤ {convergence_threshold})")
            if cycle >0:
                break

        cycle += 1

    # Sauvegarde finale
    save_optimization_results(domain, best_coeffs, best_gain_total, best_success_rate, best_trades, best_thresholds)
    return best_coeffs, best_gain_total, best_success_rate, best_thresholds



def save_optimization_results(domain, coeffs, gain_total, success_rate, total_trades, thresholds):
    """Sauvegarde les rÃ©sultats dans un CSV seulement s'ils sont les meilleurs pour le secteur"""
    from datetime import datetime
    import pandas as pd
    
    results = {
        'Timestamp': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
        'Sector': domain,
        'Gain_moy': gain_total,
        'Success_Rate': success_rate,
        'Trades': total_trades,
        'Seuil_Achat': thresholds[0],
        'Seuil_Vente': thresholds[1],
        'a1': coeffs[0], 'a2': coeffs[1], 'a3': coeffs[2], 'a4': coeffs[3],
        'a5': coeffs[4], 'a6': coeffs[5], 'a7': coeffs[6], 'a8': coeffs[7]
    }
    
    csv_path = 'signaux/optimization_hist_4stp.csv'
    
    try:
        # VÃ©rifier si le fichier existe et charger les donnÃ©es existantes
        if pd.io.common.file_exists(csv_path):
            df_existing = pd.read_csv(csv_path)
            
            # Filtrer les donnÃ©es pour le secteur concernÃ©
            sector_data = df_existing[df_existing['Sector'] == domain]
            
            if not sector_data.empty:
                # Trouver les meilleurs rÃ©sultats existants pour ce secteur
                best_gain = sector_data['Gain_moy'].max()
                best_success_rate = sector_data['Success_Rate'].max()
                
                # VÃ©rifier si les nouveaux rÃ©sultats sont meilleurs
                is_best_gain = gain_total > best_gain
                is_best_success_rate = success_rate > best_success_rate
                
                # Ne sauvegarder que si au moins un des critÃ¨res est meilleur
                if not (is_best_gain or is_best_success_rate):
                    print(f"âš ï¸ RÃ©sultats pour {domain} non sauvegardÃ©s:")
                    print(f"   Gain moyen actuel: {gain_total:.4f} (meilleur existant: {best_gain:.4f})")
                    print(f"   Taux de rÃ©ussite actuel: {success_rate:.4f} (meilleur existant: {best_success_rate:.4f})")
                    print(f"   Les nouveaux paramÃ¨tres ne sont pas meilleurs que ceux existants.")
                    return
                
                # Afficher quel critÃ¨re s'est amÃ©liorÃ©
                if is_best_gain:
                    print(f"ğŸ¯ Nouveau meilleur gain moyen pour {domain}: {gain_total:.4f} (ancien: {best_gain:.4f})")
                if is_best_success_rate:
                    print(f"ğŸ¯ Nouveau meilleur taux de rÃ©ussite pour {domain}: {success_rate:.4f} (ancien: {best_success_rate:.4f})")
        
        # Sauvegarder les nouveaux rÃ©sultats
        df_new = pd.DataFrame([results])
        df_new.to_csv(csv_path, mode='a', header=not pd.io.common.file_exists(csv_path), index=False)
        print(f"ğŸ“ RÃ©sultats sauvegardÃ©s pour {domain}")
        
    except Exception as e:
        print(f"âš ï¸ Erreur lors de la sauvegarde dans le CSV: {e}")


# Exemple d'utilisation
if __name__ == "__main__":
    # Exemple de symboles par secteur, incluant cryptomonnaies et inconnus
    symbols = list(dict.fromkeys(load_symbols_from_txt("optimisation_symbols.txt")))
    # CrÃ©er le dictionnaire des secteurs dynamiquement
    sectors = {
        "Technology": [],
        "Healthcare": [],  
        "Financial Services":[],
        "Consumer Cyclical":  [],
        "Industrials":     [],
        "Energy":          [],
        "Basic Materials": [],
        "Communication Services": [],
        "Consumer Defensive": [],
        "Utilities":      [],
        "Real Estate":  [],
        "â„¹ï¸Inconnu!!": []
    }
    
    # Assigner les symboles aux secteurs
    for symbol in symbols:
        sector = get_sector(symbol)
        if sector in sectors:
            sectors[sector].append(symbol)
        else:
            sectors["â„¹ï¸Inconnu!!"].append(symbol)
    
    print("\nğŸ“‹ Assignation des secteurs:")
    for sector, syms in sectors.items():
        print(f"{sector}: {syms}")
    
    optimized_coeffs = {}
    for sector, sector_symbols in sectors.items():
        if not sector_symbols:
            print(f"ğŸš« Secteur {sector} vide, ignorÃ©")
            continue
        it= 320 # Nombre d'itÃ©rations par Ã©tape
        coeffs, gain_total, success_rate, thresholds = optimize_sector_coefficients(
            sector_symbols, sector, period='1y', n_iterations=it, montant=50, 
            transaction_cost=0.02, max_cycles=255, convergence_threshold=0.1
        )
        if coeffs:
            optimized_coeffs[sector] = coeffs
            print(f"\nSecteur: {sector}")
            print(f"Meilleurs coefficients: {coeffs}")
            print(f"Meilleurs seuils (achat, vente): {thresholds}")
            print(f"Gain total moyen: {gain_total:.2f}")
            print(f"Taux de rÃ©ussite: {success_rate:.2f}%")
            print(f"\n")
    
    print("Dictionnaire optimisÃ© pour domain_coeffs:")
    print("{")
    for sector, coeffs in optimized_coeffs.items():
        print(f"    '{sector}': {coeffs},")
    print("}")